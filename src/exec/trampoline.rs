//! Trampoline script generation.
//!
//! Generates shell script wrappers that delegate to tramp.

use std::path::Path;

/// Generate a trampoline shell script for a binary.
///
/// The generated script:
/// - Delegates to tramp with the original binary and arguments
/// - Ensures tramp processes the command through its hook system
pub fn generate_trampoline_script(binary_path: &Path, tramp_path: Option<&Path>) -> String {
	let binary_str = binary_path.to_string_lossy();
	let tramp_cmd = tramp_path
		.map(|p| p.to_string_lossy().to_string())
		.unwrap_or_else(|| "tramp".to_string());

	format!(
		r#"#!/bin/sh
# Trampoline script generated by tramp
# This script wraps {binary} through tramp's hook system

exec "{tramp}" "{binary}" "$@"
"#,
		binary = binary_str,
		tramp = tramp_cmd,
	)
}

/// Generate the default template for --init.
pub fn generate_init_template() -> &'static str {
	r#"# .tramp.toml - Tramp configuration
# See: https://github.com/fbartho/tramp

# Stop directory cascade here and jump to ~/.tramp.toml
# (Recommended: improves performance by limiting config file searches)
root = true

# Don't allow local developer hooks to override this config
# no-external-lookup = true

# Skip ~/.tramp.toml lookup when this env var is truthy (useful for CI)
# root-config-lookup-disable-env-var = "CI"

# Rules: first matching rule wins
# Supports both [[rules]] and rules = [...] syntax

# Example: Rewrite arguments
# [[rules]]
# binary_pattern = ".*/cargo$"       # Regex to match command path
# cwd_pattern = ".*/my-project$"     # Optional: only match in specific directories
# arg_rewrite = "s/^build$/build --release/"  # Regex substitution on args
# pre_hook = "/path/to/pre-hook.sh"  # Run before command
# post_hook = "/path/to/post-hook.sh"  # Run after command

# Example: Replace with alternate command
# [[rules]]
# binary_pattern = ".*/npm$"
# alternate_command = "/usr/local/bin/pnpm"  # Mutually exclusive with arg_rewrite/command_rewrite

# Example: Rewrite entire command string
# [[rules]]
# binary_pattern = ".*/kubectl$"
# command_rewrite = "s/kubectl/kubectl --context=dev/"  # Mutually exclusive with arg_rewrite/alternate_command

# Hooks receive context via environment variables:
#   TRAMP_ORIGINAL_BINARY - path to the original command
#   TRAMP_ORIGINAL_ARGS   - original arguments as a string
#   TRAMP_ORIGINAL_ARG_N  - individual arguments (0-indexed)
#   TRAMP_CWD             - working directory
#   TRAMP_HOOK_TYPE       - "pre", "post", or "intercept"
#   TRAMP_EXIT_CODE       - exit code (post-hooks only)
"#
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_generate_trampoline_script() {
		let script = generate_trampoline_script(Path::new("/usr/local/bin/cargo"), None);

		assert!(script.contains("#!/bin/sh"));
		assert!(script.contains("exec \"tramp\" \"/usr/local/bin/cargo\" \"$@\""));
	}

	#[test]
	fn test_generate_trampoline_script_with_custom_tramp() {
		let script = generate_trampoline_script(
			Path::new("/usr/local/bin/cargo"),
			Some(Path::new("/opt/tramp/bin/tramp")),
		);

		assert!(script.contains("exec \"/opt/tramp/bin/tramp\" \"/usr/local/bin/cargo\" \"$@\""));
	}

	#[test]
	fn test_generate_init_template() {
		let template = generate_init_template();

		assert!(template.contains("root = true"));
		assert!(template.contains("# no-external-lookup = true"));
		assert!(template.contains("binary_pattern"));
		assert!(template.contains("TRAMP_ORIGINAL_BINARY"));
	}
}
